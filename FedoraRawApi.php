<?php
/**
 * @file
 * Lowest-level wrappers for Fedora Commons's REST API functions.
 * This interface describes the PHP implementation of these interfaces
 * so that we can potentially have different implementations.
 *
 * All of these functions look at the response code of the error and
 * throw FedoraAPIRestException if the response code isn't success (2XX).
 *
 * Much documentation about the API that is wraps can be found here:
 * https://wiki.duraspace.org/display/FCR30/REST+API
 */

/**
 * A low level wrapper on fedora APIA functions
 * @todo Fix the Exceptions
 */
interface FedoraApiA {

  /**
   * Constructor for a new FedoraAPI object.
   *
   * @throws FedoraException
   *
   * @param FedoraConnection $connection
   *   (optional) a new one will be created if not supplied.
   */
  public function __construct($connection = NULL, $request = NULL);

  /**
   * Query fedora to return a list of objects.
   *
   * @param string $type
   *   Valid options are: 'terms' or 'query'. This is the type of the search being done. This corresponds to the
   *   structure of the next arguement.
   * @param string $query
   *   There are two different arguements that can be passed into this function depending on the type.
   *   - Type = Terms:
   *     A phrase represented as a sequence of characters (including the ? and * wildcards) for the search.
   *     If this sequence is found in any of the fields for an object, the object is considered a match.
   *   - Type = Query:
   *     A sequence of space-separated conditions. A condition consists of a metadata element name followed
   *     directly by an operator, followed directly by a value. Valid element names are (pid, label, state, ownerId,
   *     cDate, mDate, dcmDate, title, creator, subject, description, publisher, contributor, date, type, format,
   *     identifier, source, language, relation, coverage, rights). Valid operators are: contains (), equals (=),
   *     greater than (>), less than (<), greater than or equals (>=), less than or equals (<=). The contains () operator
   *     may be used in combination with the ? and * wildcards to query for simple string patterns. Values may be any
   *     string. If the string contains a space, the value should begin and end with a single quote character ('). If
   *     all conditions are met for an object, the object is considered a match. Do NOT use this parameter in combination
   *     with the "terms" parameter.
   * @param string,int $maxResults
   *   (optional) Default: 25. The maximum number of results that the server should provide at once.
   * @param array $displayFields
   *   (optional) Default: array('pid', 'title'). The fields to be returned.
   * @param string $resultFormat
   *   (optional) Default: XML. The preferred output format. Options: HTML, XML.
   *
   * @throws FedoraException
   *
   * @return Response object. 'data' has XML set of results
   * @code
   *   <?xml version="1.0" encoding="UTF-8"?>
   *   <result xmlns="http://www.fedora.info/definitions/1/0/types/">
   *     <resultList>
   *     <objectFields>
   *       <pid>islandora:collectionCModel</pid>
   *       <title>Islandora Collection Content Model</title>
   *     </objectFields>
   *     <objectFields>
   *       <pid>islandora:strict_pdf</pid>
   *       <title>Strict PDF</title>
   *     </objectFields>
   *     </resultList>
   *   </result>
   * @endcode
   */
  public function findObjects($type = '', $query = '', $maxResults = '', $displayFields = array('pid', 'title'),
       $resultFormat = 'xml');

  /**
   * Get the default dissemination of a datastream. (Get the contents of the datastream.)
   *
   * @param String $pid
   *   Persistent identifier of the digital object.
   * @param String $dsID
   *   Datastream identifier.
   * @param String $asOfDateTime
   *   (optional) Default: NULL. Indicates that the result should be relative to the digital object as it existed
   *   at the given date and time.
   * @param String $download
   *   (optional) Default: FALSE. If true, a content-disposition header value "attachment" will be included in the
   *   response, prompting the user to save the datastream as a file.  A content-disposition header value "inline"
   *   will be used otherwise.  The filename used in the header is generated by examining in order: RELS-INT for the
   *   relationship fedora-model:downloadFilename, the datastream label, and the datastream ID.  The file extension
   *   (apart from where the filename is specified in RELS-INT) is determined from the MIMETYPE.  The order in which
   *   these filename sources are searched, and whether or not to generate an extension from the MIMETYPE, is
   *   configured in fedora.fcfg.  The file used to map between MIMETYPEs and extensions is mime-to-extensions.xml
   *   located in the server config directory.
   *
   * @throws FedoraException
   *
   * @return Response object.
   */
  public function getDatastreamDissemination($pid, $dsID, $asOfDateTime = NULL, $download = NULL) {}

  /**
   * Get a datastream dissemination from Fedora.
   *
   * @param String $pid
   *   persistent identifier of the digital object
   * @param String $sdefPid
   *   persistent identifier of the sDef defining the methods
   * @param String $method
   *   method to invoke
   * @param String $methodParameters
   *   A key-value paired array of parameters required by the method
   *
   * @return StdClass HTTP response object from fedora
   */
  public function getDissemination($pid, $sdefPid, $method, $methodParameters = array()) {
    $pid = drupal_encode_path($pid);
    $sdefPid = drupal_encode_path($sdefPid);

    $fedora_url = $this->connection->requestURL();
    $request = "$fedora_url/objects/$pid/methods/$sdefPid/$method?";

    //$request .= (!empty($asOfDateTime) ? "&asOfDateTime=$asOfDateTime" : '');
    foreach ($methodParameters as $param_name => $param_value) {
      $request .= $param_name . (!empty($param_value) ? "=$param_value&" : '&');
    }

    $response = drupal_http_request($request);

    if(!FedoraAPIUtils::testSuccess($response)) {
      throw new FedoraApiRestException($response);
    }

    return $response;
  }

  /**
   * Get the change history for the datastream.
   *
   * @param String $pid
   *   Persistent identifier of the digital object.
   * @param String $format
   *   (Optional) Default: XML. The preferred output format (xml, html).
   *
   * @return HTTP response object.
   * @code
   *   $response->data looks like:
   *   <?xml version="1.0" encoding="utf-16"?>
   *   <fedoraObjectHistory xsi:schemaLocation="http://www.fedora.info/definitions/1/0/access/
   *     http://localhost:8080/fedoraObjectHistory.xsd" pid="demo:29" xmlns:xsd="http://www.w3.org/2001/XMLSchema"
   *     xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
   *       <objectChangeDate>2008-07-02T05:09:43.234Z</objectChangeDate>
   *   </fedoraObjectHistory>
   *  @endcode
   */
  public function getObjectHistory($pid, $format = 'xml') {
    $pid = drupal_encode_path($pid);
    $fedora_url = $this->connection->requestURL();

    $request = "$fedora_url/objects/$pid/versions?format=$format";
    $response = drupal_http_request($request);

    if(!FedoraAPIUtils::testSuccess($response)) {
      throw new FedoraApiRestException($response);
    }

    return $response;
  }

  /**
   * Implements the getObjectProfile Fedora API-A method.
   *
   * @param String $pid
   *   Persistent identifier of the digital object.
   * @param String $format
   *   (Optional) Default: XML. The preferred output format. Options: HTML, XML.
   * @param String $asOfDateTime
   *   (Optional) Indicates that the result should be relative to the digital object as it existed on the given date.
   *   Date Format: yyyy-MM-dd or yyyy-MM-ddTHH:mm:ssZ
   *
   * @return StdClass HTTP Response object. 'data' has XML response string
   * @code
   *   <?xml version="1.0" encoding="utf-16"?>
   *   <objectProfile xsi:schemaLocation="http://www.fedora.info/definitions/1/0/access/
   *   http://localhost:8080/objectProfile.xsd" pid="islandora:demos"
   *   xmlns:xsd="http://www.w3.org/2001/XMLSchema"
   *   xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
   *     <objLabel>Islandora Demo Collections</objLabel>
   *     <objOwnerId>fedoraAdmin</objOwnerId>
   *     <objModels>
   *       <model>info:fedora/islandora:collectionCModel</model>
   *       <model>info:fedora/fedora-system:FedoraObject-3.0</model>
   *     </objModels>
   *     <objCreateDate>2009-03-10T07:09:53.333Z</objCreateDate>
   *     <objLastModDate>2010-03-20T23:39:58.490Z</objLastModDate>
   *     <objDissIndexViewURL>
   *         http://localhost:8080/fedora/get/islandora:demos/fedora-system:3/viewMethodIndex
   *     </objDissIndexViewURL>
   *     <objItemIndexViewURL>
   *         http://localhost:8080/fedora/get/islandora:demos/fedora-system:3/viewItemIndex
   *     </objItemIndexViewURL>
   *     <objState>A</objState>
   *   </objectProfile>
   * @endcode
   */
  public function getObjectProfile($pid, $format = 'xml', $asOfDateTime = '') {
    $pid = drupal_encode_path($pid);
    $fedora_url = $this->connection->requestURL();

    $request = "$fedora_url/objects/$pid?format=$format";
    $request .= (!empty($asOfDateTime) ? "&asOfDateTime=$asOfDateTime" : '');
    $response = drupal_http_request($request);

    if(!FedoraAPIUtils::testSuccess($response)) {
      throw new FedoraApiRestException($response);
    }

    return $response;
  }

  /**
   * List all the datastreams that are associated with this PID.
   *
   * @param <type> $pid
   *   Persistent identifier of the digital object.
   * @param <type> $format
   *   (optional) Default: XML. The preferred output format. Options: XML, HTML.
   * @param <type> $asOfDateTime
   *   (optional) Indicates that the result should be relative to the digital object as it existed on the given date.
   *   Date Format: yyyy-MM-dd or yyyy-MM-ddTHH:mm:ssZ
   *
   * @return StdClass HTTP Response object. 'data' has XML Response
   * @code
   *   <?xml version="1.0" encoding="utf-16"?>
   *   <objectDatastreams xsi:schemaLocation="http://www.fedora.info/definitions/1/0/access/
   *     http://localhost:8080/listDatastreams.xsd" pid="islandora:demos" baseURL="http://localhost:8080/fedora/"
   *     xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
   *     <datastream dsid="DC" label="Dublin Core Record for this object" mimeType="text/xml" />
   *     <datastream dsid="RELS-EXT" label="RDF Statements about this object" mimeType="application/rdf+xml" />
   *     <datastream dsid="COLLECTION_POLICY" label="Collection Policy" mimeType="text/xml" />
   *     <datastream dsid="TN" label="Thumbnail.png" mimeType="image/png" />
   *   </objectDatastreams>
   * @endcode
   */
  public function listDatastreams($pid, $format = 'xml', $asOfDateTime = '') {
    $pid = drupal_encode_path($pid);
    $fedora_url = $this->connection->requestURL();

    $request = "$fedora_url/objects/$pid/datastreams?format=$format";
    $request .= (!empty($asOfDateTime) ? "&asOfDateTime=$asOfDateTime" : '');
    $response = drupal_http_request($request);

    if(!FedoraAPIUtils::testSuccess($response)) {
      throw new FedoraApiRestException($response);
    }

    return $response;
  }

  /**
   * Implements the listMethods Fedora API-A method.
   *
   * @param String $pid
   *   Persistent identifier of the digital object.
   * @param String $sdefPid
   *   (Optional) Persistent identifier of the SDef defining the methods.
   * @param String $format
   *   (Optional) Default: XML. The preferred output format. Options: XML, HTML.
   * @param String $asOfDateTime
   *   (Optional) Indicates that the result should be relative to the digital object as it existed on the given date.
   *   Date Format: yyyy-MM-dd or yyyy-MM-ddTHH:mm:ssZ
   *
   * @return StdClass HTTP Response object. 'data' has response XML.
   * @code
   *   <?xml version="1.0" encoding="utf-16"?>
   *   <objectMethods xsi:schemaLocation="http://www.fedora.info/definitions/1/0/access/
   *   http://localhost:8080/listMethods.xsd" pid="islandora:demos" baseURL="http://localhost:8080/fedora/"
   *   xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
   *     <sDef pid="fedora-system:3">
   *         <method name="viewObjectProfile"></method>
   *         <method name="viewMethodIndex"></method>
   *         <method name="viewItemIndex"></method>
   *         <method name="viewDublinCore"></method>
   *     </sDef>
   *   </objectMethods>
   * @endcode
   */
  public function listMethods($pid, $sdefPid = '', $format = 'xml', $asOfDateTime = '') {
    $pid = drupal_encode_path($pid);
    $fedora_url = $this->connection->requestURL();

    $request = "$fedora_url/objects/$pid/methods";
    $request .= (!empty($sdefPid) ? "/$sdefPid" : '');
    $request .= "?format=$format";
    $request .= (!empty($asOfDateTime) ? "&asOfDateTime=$asOfDateTime" : '');
    $response = drupal_http_request($request);

    if(!FedoraAPIUtils::testSuccess($response)) {
      throw new FedoraApiRestException($response);
    }

    return $response;
  }
}


/**
 * A low level wrapper on fedora APIM functions
 */
class FedoraAPIM {
  /**
   * The FedoraConnection object for this FedoraAPIM.
   *
   * @var FedoraConnection
   */
  public $connection;

  /**
   * Constructor for a new FedoraAPIM object.
   *
   * @param FedoraConnection $connection
   *   (optional) a new one will be created if not supplied.
   */
  function __construct($connection = NULL) {
    if ($connection != NULL) {
      $this->connection = $connection;
    }
    else {
      // Construct a connection from Drupal's API settings.
      $this->connection = new FedoraConnection();
    }

  }


  /**
   * Add a new datastream to a fedora object. The datastreams are sent to Fedora using a multipart post if a string or
   * file is provided. Otherwise the dsLocation field is used. $file_path, $ds_string and $params['dsLocation'] are
   * all optional, however ONE and only ONE must be specified for this function.
   *
   * @param string $pid
   *   Persistent identifier of the digital object.
   * @param string $dsID
   *   Datastream identifier.
   * @param <type> $file_path
   *   (Optional)
   * @param <type> $ds_string
   *   (Optional)
   * @param <type> $params
   *   (Optional)
   *
   * @return <type>
   *
   * @todo Do more sophisticated MIME type detection. Possibly including retrieving headers of dsLocation.
   * @todo Figure out the multipart mimetype function here. I think it is buggy and should be using a dynamically
   *   generated boundry. I also think that we should be passing strings through the multipart mimetype functionalty.
   *   Much of this code was taken from here: http://drupal.org/node/270997.
   *   There is some good RFC documentation on this here:
   *     http://tools.ietf.org/html/rfc2388
   *     http://tools.ietf.org/html/rfc2046#section-5
   *     http://tools.ietf.org/html/rfc2045#page-14
   *     http://www.w3.org/TR/REC-html40/interact/forms.html#h-17.13.4.2
   * @todo also sort out the commented code in this function
   */
  public function addDatastream(
    $pid, $dsID, $file_path = NULL, $ds_string = NULL,
    $params = array(
      'controlGroup' => NULL,
      'dsLocation' => NULL,
      'altIDs' => NULL,
      'dsLabel' => NULL,
      'dsState' => NULL,
      'formatURI' => NULL,
      'checksumType' => NULL,
      'checksum' => NULL,
      'mimeType' => NULL,
      'logMessage' => NULL,
    )
  ) {
    $pid = drupal_encode_path($pid);

    foreach (array('dsLabel', 'formatURI', 'logMessage') as $string_param) {
      if (key_exists($string_param, $params) && $params[$string_param] != NULL) {
        $params[$string_param] = drupal_encode_path($params[$string_param]);
      }
    }

    $request_params = NULL;

    $headers = array();

    if (!empty($params['dsLocation'])) {
      if ($params['controlGroup'] == 'X') {
        $headers['Content-Type'] = 'text/xml';
      }
      elseif (!empty($params['mimeType'])) {
        $headers['Content-Type'] = $params['mimeType'];
      }
      else {
        // TODO: More sophisticated MIME type detection. Possibly including retrieving headers of dsLocation
        $headers['Content-Type'] = 'application/x-octet-stream';
      }
    }
    elseif (!empty($file_path)) {
      // We must construct a multipart HTTP POST.
      $boundary = 'A0sFSD';
      $headers["Content-Type"] = "multipart/form-data; boundary=$boundary";
      $request_params = FedoraAPIUtils::multipartEncode($boundary, array('file' => $file_path));
    }
    elseif (!empty($ds_string)) {
      // We must construct a multipart HTTP POST.
      $boundary = 'A0sFSD';
      $headers["Content-Type"] = "text/plain";
      $request_params = $ds_string;
      //$request_params = _fedora_api_multipart_encode($boundary, array('string' => $ds_string));
    }
    else {
      return NULL;
    }

    $fedora_url = $this->connection->requestURL();
    $request = $fedora_url . "/objects/$pid/datastreams/$dsID?";

    foreach ($params as $param_name => $param_value) {
      $request .= $param_value != NULL ? "$param_name=$param_value&" : '';
    }

    $response = drupal_http_request($request, array('headers' => $headers, 'method' => 'POST', 'data' => $request_params));

    if(!FedoraAPIUtils::testSuccess($response)) {
      throw new FedoraApiRestException($response);
    }


    return $response;
  }

  /**
   * Export a Fedora object with the given PID.
   *
   * @param String $pid
   *   Persistent identifier of the digital object.
   * @param String $format
   *   (Optional) The XML format to export. Options: info:fedora/fedora-system:FOXML-1.1 (default),
   *   info:fedora/fedora-system:FOXML-1.0, info:fedora/fedora-system:METSFedoraExt-1.1,
   *   info:fedora/fedora-system:METSFedoraExt-1.0, info:fedora/fedora-system:ATOM-1.1,
   *   info:fedora/fedora-system:ATOMZip-1.1
   * @param String $context
   *   (Optional) The export context, which determines how datastream URLs and content are represented.
   *   Options: public (default), migrate, archive
   * @param String $encoding
   *   (Optional) The preferred encoding of the exported XML.
   * @return StdClass HTTP Response object. The 'data' element contains the requested export data.
   */
  public function export(
    $pid,
    $format = 'info:fedora/fedora-system:FOXML-1.1',
    $context = 'public', $encoding = 'UTF-8'
  ) {
    $pid = drupal_encode_path($pid);
    $format = drupal_encode_path($format);

    $fedora_url = $this->connection->requestURL();
    $request = $fedora_url . "/objects/$pid/export?";

    $request .= (!empty($format) ? "format=$format&" : '')
             . (!empty($context) ? "context=$context&" : '')
             . (!empty($encoding) ? "encoding=$encoding" : '');
    $response = drupal_http_request($request);

    if(!FedoraAPIUtils::testSuccess($response)) {
      throw new FedoraApiRestException($response);
    }

    return $response;
  }

 /**
  * Returns the XML metadata information about a datastream.
  *
  * @param String $pid
  *   Persistent identifier of the digital object.
  * @param String $dsID
  *   Datastream identifier.
  * @param String $format
  *   (optional) Default: xml. The preferred output format. Options: xml or html.
  * @param String $asOfDateTime
  *   (optional) Indicates that the result should be relative to the digital object as it existed on the given date.
  *   Format: yyyy-MM-dd or yyyy-MM-ddTHH:mm:ssZ
  * @param String $validateChecksum
  *   (optional) verifies that the Datastream content has not changed since the checksum was initially computed. If
  *   asOfDateTime is null, Fedora will use the most recent version.
  *
  * @return StdClass HTTP Response object. 'data' has XML set of results.
  * @code
  *   <?xml version="1.0" encoding="UTF-8"?>
  *   <datastreamProfile xmlns="http://www.fedora.info/definitions/1/0/management/"
  *     xmlns:xsd="http://www.w3.org/2001/XMLSchema"
  *     xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  *     xsi:schemaLocation="http://www.fedora.info/definitions/1/0/management/
  *     http://www.fedora.info/definitions/1/0/datastreamProfile.xsd"
  *     pid="demo:2" dsID="DC">
  *   <dsLabel>Dublin Core Record</dsLabel>
  *   <dsVersionID>DC.0</dsVersionID>
  *   <dsCreateDate>2011-05-05T13:23:58.858Z</dsCreateDate>
  *   <dsState>A</dsState>
  *   <dsMIME>text/xml</dsMIME>
  *   <dsFormatURI/>
  *   <dsControlGroup>X</dsControlGroup>
  *   <dsSize>753</dsSize>
  *   <dsVersionable>true</dsVersionable>
  *   <dsInfoType/>
  *   <dsLocation>demo:2+DC+DC.0</dsLocation>
  *   <dsLocationType/>
  *   <dsChecksumType>DISABLED</dsChecksumType>
  *   <dsChecksum>none</dsChecksum>
  *   </datastreamProfile>
  * @endcode
  */
  public function getDatastream($pid, $dsID, $format = 'xml', $asOfDateTime = NULL, $validateChecksum = FALSE) {
    $pid = drupal_encode_path($pid);
    $fedora_url = $this->connection->requestURL();
    $request = "$fedora_url/objects/$pid/datastreams/$dsID";
    $format = strtolower($format);
    $separator = '?';
    if (in_array($format, array('html', 'xml'))) {
      $request .= "{$separator}format=$format";
      $separator = '&';
    }
    if (!empty($asOfDateTime)) {
      $request .= "{$separator}asOfDateTime=$asOfDateTime";
      $separator = '&';
    }
    if (!empty($validateChecksum)) {
      $request .= "{$separator}validateChecksum=$validateChecksum";
    }
    $response = drupal_http_request($request);

    if(!FedoraAPIUtils::testSuccess($response)) {
      throw new FedoraApiRestException($response);
    }

    return $response;
  }

  /**
   * Get a new PID.
   *
   * @param int $numPIDS
   *   (Optional) Default: 1.
   * @param string $namespace
   *   (Optional) Default: ''
   * @param string $format
   *   (Optional) Options: XML (default), HTML
   * @return StdClass HTTP response
   * @code
   * <?xml version="1.0" encoding="UTF-8"?>
   * <pidList  xmlns:xsd="http://www.w3.org/2001/XMLSchema"
   *   xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
   *   xsi:schemaLocation="http://www.fedora.info/definitions/1/0/management/
   *   http://localhost:8080/getNextPIDInfo.xsd">
   *   <pid>changeme:2</pid>
   * </pidList>
   * @endcode
   *
   * @todo clean up the reqaut code to make it more readable.
   * @todo should we make the namespace default more sensible, something like islandora?
   */
  public function getNextPID($numPIDS = 1, $namespace = '', $format = 'xml') {
    $fedora_url = $this->connection->requestURL();
    $request = $fedora_url . "/objects/nextPID?";
    $request .= (!empty($numPIDS) ? "numPIDS=$numPIDS&" : '')
             . (!empty($namespace) ? "namespace=$namespace&" : '')
             . (!empty($format) ? "format=$format" : '');
    $response = drupal_http_request($request, array('headers' => array(), 'method' => 'POST'));

    if(!FedoraAPIUtils::testSuccess($response)) {
      throw new FedoraApiRestException($response);
    }

    return $response;
  }

  /**
   * Get the fedora objects XML.
   *
   * @param String $pid
   * @return StdClass HTTP response object.
   */
  public function getObjectXML($pid) {
    $pid = drupal_encode_path($pid);
    $fedora_url = $this->connection->requestURL();
    $request = $fedora_url . "/objects/$pid/objectXML";
    $response = drupal_http_request($request);

    if(!FedoraAPIUtils::testSuccess($response)) {
      throw new FedoraApiRestException($response);
    }

    return $response;
  }

  /**
   * Ingest a FOXML item into Fedora. This could be a string, a file, or a reference to a file that Fedora will
   * go and retreve.
   *
   * @param String $foxml_file
   * @param String $foxml_string
   * @param String $pid
   * @param String $new
   * @param String $label
   * @param String $format
   * @param String $encoding
   * @param String $namespace
   * @param String $ownerId
   * @param String $logMessage
   * @param String $ignoreMime
   * @return StdClass HTTP Response Object
   * $response->data contains just the PID of the ingested object (plain text).
   *
   * @todo See the notes for addDatastream. I think we should revisit how the REST calls are done
   *   on this function.
   */
  public function ingest( $foxml_file = NULL, $foxml_string = NULL, $pid = NULL, $new = TRUE, $label = NULL,
    $format = 'info:fedora/fedora-system:FOXML-1.1', $encoding = 'UTF-8', $namespace = NULL, $ownerId = NULL,
    $logMessage = NULL, $ignoreMime = 'false'
  ){
    if (empty($pid)) {
      // Set $new to TRUE regardless of what the user specified if no PID is given
      $pid = "new";
    }
    else {
      $pid = drupal_encode_path($pid);
    }
    $label = drupal_encode_path($label);
    $format = drupal_encode_path($format);
    $logMessage = drupal_encode_path($logMessage);
    $params = NULL;
    $headers = array(
      'Keep-Alive' => 115,
      'Connection' => 'keep-alive',
    );
    if (!empty($foxml_file)) {
      // We must construct a multipart HTTP POST.
      $boundary = 'A0sFSD';
      $headers["Content-Type"] = "multipart/form-data; boundary=$boundary";
      $params = FedoraAPIUtils::multipartEncode($boundary, array('foxml_file' => $foxml_file));
    }
    elseif (!empty($foxml_string)) {
      // We must construct a multipart HTTP POST.
      $boundary = 'A0sFSD';
      $headers["Content-Type"] = "multipart/form-data; boundary=$boundary";
      $params = FedoraAPIUtils::multipartEncode($boundary, array('foxml_string' => $foxml_string));
    }

    $fedora_url = $this->connection->requestURL();

    $request = $fedora_url . "/objects/$pid?";

    $request .= (!empty($label) ? "label=$label&" : '')
             . (!empty($format) ? "format=$format&" : '')
             . (!empty($encoding) ? "encoding=$encoding&" : '')
             . (!empty($namespace) ? "namespace=$namespace&" : '')
             . (!empty($ownerId) ? "ownerId=$ownerId&" : '')
             . (!empty($logMessage) ? "logMessage=$logMessage&" : '')
             . (!empty($ignoreMime) ? "ignoreMime=$ignoreMime&" : '');
    $response = drupal_http_request($request, array('headers' => $headers, 'method' => 'POST', 'data' => $params));

    if(!FedoraAPIUtils::testSuccess($response)) {
      throw new FedoraApiRestException($response);
    }

    return $response;

  }

  /**
   * Modify the parameters of a Fedora datastream.
   *
   * Note: Due ot a bug in Fedora you need to specify the Mime Type for each call.
   *
   * @param <type> $pid
   * @param <type> $dsID
   * @param <type> $file_path
   * @param <type> $dsLocation
   * @param <type> $altIDs
   * @param <type> $dsLabel
   * @param <type> $versionable
   * @param <type> $dsState
   * @param <type> $formatURI
   * @param <type> $checksumType
   * @param <type> $checksum
   * @param <type> $mimeType
   * @param <type> $logMessage
   * @param <type> $force
   * @param <type> $ignoreContent
   * @return StdClass HTTP response object
   * @code
   * <?xml version="1.0" encoding="utf-16"?>
   * <datastreamProfile xsi:schemaLocation="http://www.fedora.info/definitions/1/0/management/
   *   http://localhost:8080/datastreamProfile.xsd" pid="islandora:demos" dsID="TN"
   *   xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
   *     <dsLabel>Thumbnail.png</dsLabel>
   *     <dsVersionID>TN.4</dsVersionID>
   *     <dsCreateDate>2010-04-08T12:27:01.966Z</dsCreateDate>
   *     <dsState>A</dsState>
   *     <dsMIME>image/png</dsMIME>
   *     <dsFormatURI/>
   *     <dsControlGroup>M</dsControlGroup>
   *     <dsSize>0</dsSize>
   *     <dsVersionable>true</dsVersionable>
   *     <dsInfoType/>
   *     <dsLocation>islandora:demos+TN+TN.4</dsLocation>
   *     <dsLocationType>INTERNAL_ID</dsLocationType>
   *     <dsChecksumType>DISABLED</dsChecksumType>
   *     <dsChecksum>none</dsChecksum>
   * </datastreamProfile>
   * @endcode
   *
   * @todo Verify the claim above about mimetypes. Perhaps reference a Fedora issue numebr.
   * @todo Finish the PHPDoc for this function.
   * @todo Cleanup the commented out code specifying the headers.
   */
  public function modifyDatastream( $pid, $dsID, $file_path = NULL, $ds_string = NULL,
    $params = array(
      'dsLocation' => NULL,
      'altIDs' => NULL,
      'dsLabel' => NULL,
      'versionable' => NULL,
      'dsState' => NULL,
      'formatURI' => NULL,
      'checksumType' => NULL,
      'checksum' => NULL,
      'mimeType' => NULL,
      'logMessage' => NULL,
      'force' => NULL,
      'ignoreContent' => NULL
    )
  ){
    $pid = drupal_encode_path($pid);

    foreach (array('dsLabel', 'formatURI', 'logMessage') as $string_param) {
      if (key_exists($string_param, $params) && $params[$string_param] != NULL) {
        $params[$string_param] = drupal_encode_path($params[$string_param]);
      }
    }

    $request_params = NULL;
    $headers = array(
   //   'Keep-Alive' => 115,
   //   'Connection' => 'keep-alive',
    );

    $fedora_url = $this->connection->requestURL();

    $request = $fedora_url . "/objects/$pid/datastreams/$dsID?";

    foreach ($params as $param_name => $param_value) {
      $request .= $param_value != NULL ? "$param_name=$param_value&" : '';
    }

    $data = (!empty($file_path) ? file_get_contents($file_path) : $ds_string);
    $response = drupal_http_request($request, array('headers' => $headers, 'method' => 'PUT', 'data' => $data));

    if(!FedoraAPIUtils::testSuccess($response)) {
      throw new FedoraApiRestException($response);
    }

    return $response;
  }

  /**
   * @todo Please document this function.
   */
  public function modifyObject($pid, $label = NULL, $ownerId = NULL, $state = NULL, $logMessage = NULL) {
    $pid = drupal_encode_path($pid);
    $label = drupal_encode_path($label);
    $logMessage = drupal_encode_path($logMessage);
    $fedora_url = $this->connection->requestURL();
    $request = $fedora_url . "/objects/$pid?";
    $request .= (!empty($label) ? "label=$label&" : '')
             . (!empty($ownerId) ? "ownerId=$ownerId&" : '')
             . (!empty($state) ? "state=$state" : '')
             . (!empty($logMessage) ? "logMessage=$logMessage" : '');
    $response = drupal_http_request($request, array('headers' => array(), 'method' => 'PUT'));

    if(!FedoraAPIUtils::testSuccess($response)) {
      throw new FedoraApiRestException($response);
    }

    return $response;
  }

  /**
   * Purge a datastream, deleting its contents and all its revisions.
   *
   * @param String $pid
   *   Persistent identifier of the digital object.
   * @param String $dsID
   *   Datastream identifier.
   * @param String $startDT
   *   (Optional) Format: yyyy-MM-dd or yyyy-MM-ddTHH:mm:ssZ - the (inclusive) start date-time stamp of the range.
   *   If not specified, this is taken to be the lowest possible value, and thus, the entire version history up to
   *   the endDT will be purged.
   * @param String $endDT
   *   (Optional) Format: yyyy-MM-dd or yyyy-MM-ddTHH:mm:ssZ - the (inclusive) ending date-time stamp of the range. If
   *   not specified, this is taken to be the greatest possible value, and thus, the entire version history back to the
   *   startDT will be purged.
   * @param String $logMessage
   *   (Optional) A message describing the activity being performed.
   * @param String $force
   *   (Optional) Options: true, false (default). Force the update even if it would break a data contract.
   * @return StdClass HTTP response object
   *   On Success $response->code will be 204 and $response->error will be 'No content'.
   */
  public function purgeDatastream($pid, $dsID, $startDT = '', $endDT = '', $logMessage = '', $force = 'false') {
    $pid = drupal_encode_path($pid);
    $logMessage = drupal_encode_path($logMessage);
    $fedora_url = $this->connection->requestURL();
    $request = $fedora_url . "/objects/$pid/datastreams/$dsID?";
    $request .= (!empty($startDT) ? "startDT=$startDT&" : '')
             . (!empty($endDT) ? "endDT=$endDT&" : '')
             . (!empty($logMessage) ? "logMessage=$logMessage" : '')
             . (!empty($force) ? "force=$force" : '');
    $response = drupal_http_request($request, array('headers' => array(), 'method' => 'DELETE'));

    if(!FedoraAPIUtils::testSuccess($response)) {
      throw new FedoraApiRestException($response);
    }

    return $response;
  }

  /**
   * Purge an object.
   *
   * @param String $pid
   *   Persistent identifier of the digital object.
   * @param String $logMessage
   *   (Optional) A message describing the activity being performed.
   * @param String $force
   *   (Optional) Options: true, false (default). Force the update even if it would break a data contract.
   * @return StdClass HTTP Response object
   * $response->code is 204 on successful delete, $response->error is "No content".
   */
  public function purgeObject($pid, $logMessage = '', $force = 'false') {
    $pid = drupal_encode_path($pid);
    $logMessage = drupal_encode_path($logMessage);
    $fedora_url = $this->connection->requestURL();
    $request = $fedora_url . "/objects/$pid?";
    $request .= (!empty($logMessage) ? "logMessage=$logMessage" : '')
             . (!empty($force) ? "force=$force" : '');
    $response = drupal_http_request($request, array('headers' => array(), 'method' => 'DELETE'));

    if(!FedoraAPIUtils::testSuccess($response)) {
      throw new FedoraApiRestException($response);
    }

    return $response;
  }

}


/**
 * A collection of helpful utilities for dealing with fedora.
 *
 * @todo Should this be refactored out into its own file?
 */
class FedoraAPIUtils {

  /**
   * Tests if the given PID fits the general rules for a PID. Must start with a letter, must be less the 64 characters,
   * no special characters, etc. This says nothing about the PID existing, it just tests the string with a regular
   * expression.
   *
   * @param String $pid
   *
   * @return boolean
   *
   * @todo Document where this regex came from. I believe it is in the Fedora documentation somewhere.
   */
  static function validPid($pid) {
    $valid = FALSE;
    if (strlen(trim($pid)) <= 64 && preg_match('/^([A-Za-z0-9]|-|\.)+:(([A-Za-z0-9])|-|\.|~|_|(%[0-9A-F]{2}))+$/', trim($pid))) {
      $valid = TRUE;
    }

    return $valid;
  }

  /**
   * Tests if the given DSID is valid. As above, this function is just a regular expression to validate the DSID, it
   * says nothing about the DSID actually existing.
   *
   * @param string $dsid
   *
   * @return boolean
   *
   * @todo As above we should document where this regex came from. I know I have seen it in the Fedora documenation
   *   somewhere before.
   */
  static function validDsid($dsid) {
    $valid = FALSE;
    if (strlen(trim($dsid)) <= 64 && preg_match('/^[a-zA-Z0-9\_\-\.]+$/', trim($dsid))) {
      $valid = TRUE;
    }

    return $valid;
  }

  /**
   * This function takes a string, and returns a string that is a valid DSID. This is very useful if using filenames
   * as DSIDs as most operating systems file names are less restrictive then DSIDs. This matches the Python
   * implementation of this function.
   * The algorithm is:
   * 1) It removes all characters that are unsupported in a DSID.
   * 2) If the string is too long, it takes the last 64 characters of the string.
   * 3) If the string starts with a number, prepend random letter.
   * 4) If string is empty, make is a random 10 character string.
   *
   * @param String $dsid
   * @return String
   *   The mangled DSID.
   */
  static function mangleDsid($dsid) {
    $new_dsid = trim($dsid);

    $string_array = 'abcdefghijklmnopqustuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ';

    $find = '/[^a-zA-Z0-9\.\_\-]/';
    $replace = '';
    $new_dsid = preg_replace($find, $replace, $new_dsid);

    if( strlen($new_dsid) > 64 ) {
      $new_dsid = substr($new_dsid, -64);
    }

    if( preg_match('/^[^a-zA-Z]/', $dsid )) {
      if( strlen($new_dsid) == 64 ) {
        $new_dsid = substr($new_dsid, -63);
      }
      $new_dsid = this::randomString() . $new_dsid;
    }

    if( strlen($new_dsid) == 0 )
      $new_dsid = this::randomString(10);

    return $new_dsid;
  }

  // This is defined for the function above
  private static function randomString($length = 1) {
    $array = 'abcdefghijklmnopqustuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ';

    $string = '';

    while( $length > 0 ) {
      $string .= $array[rand(0,51)];
      $length--;
    }

    return $string;
  }


  /**
   * Returns TRUE if the http response code in the supplied $http_response is a 2XX success code.
   *
   * @todo make sure this is correct
   * @todo should we be logging here
   * @param StdObject $http_response
   */
  static function testSuccess($http_response, $log = FALSE, $request = '') {
    $code = (string) $http_response->code;

    if( $code[0] == '2' ) {
      return TRUE;
    }
    else {
      if( $log == TRUE ) {
        this::logError($http_response, $request);
      }
      return FALSE;
    }
  }

  static function logError($http_response, $request) {
    watchdog('fedora api', 'Error executing Fedora REST request %request: %error',
      array('%request' => $request, '%error' => $http_response->error), WATCHDOG_ERROR
    );
  }

  static function multipartEncode($boundary, $params) {
    if (empty($params)) {
      return NULL;
    }

    $output = "";
    foreach ($params as $key => $value) {
      $output .= "--$boundary\r\n";
      if ($key == 'file') {
        $output .= this::multipartEncodeFile($value);
      }
      elseif ($key == 'foxml_file') {
        $output .= this::multipartEncodeXMLFile($value);
      }
      elseif ($key == 'foxml_string') {
        $output .= this::multipartEncodeXMLString($value);
      }
      else {
        $output .= this::multipartEncodeText($key, $value);
      }
    }
    $output .= "--$boundary--";
    return $output;
  }

  protected static function multipartEncodeFile($path) {
    // remove @ at beginning
    if (substr($path, 0, 1) == "@") {
      $path = substr($path, 1);
    }
    $filename = basename($path);
    $mimetype = "application/octet-stream";
    $data = "Content-Disposition: form-data; name=\"file\"; filename=\"$filename\"\r\n";
    $data .= "Content-Transfer-Encoding: binary\r\n";
    $data .= "Content-Type: $mimetype\r\n\r\n";
    $data .= file_get_contents($path) . "\r\n";
    return $data;
  }

  protected static function multipartEncodeXMLFile($path) {
    if (substr($path, 0, 1) == "@") {
      $path = substr($path, 1);
    }
    $filename = basename($path);
    $mimetype = "text/xml";
    $data = "Content-Disposition: form-data; name=\"file\"; filename=\"$filename\"\r\n";
    $data .= "Content-Transfer-Encoding: UTF-8\r\n";
    $data .= "Content-Type: $mimetype\r\n\r\n";
    $data .= file_get_contents($path) . "\r\n";
    return $data;
  }

  protected static function multipartEncodeXMLString($xml_data) {
    $mimetype = "text/xml";
    $data = "Content-Disposition: form-data; name=\"foxml\"; filename=\"FOXML\"\r\n";
    $data .= "Content-Transfer-Encoding: UTF-8\r\n";
    $data .= "Content-Type: $mimetype\r\n\r\n";
    $data .= $xml_data . "\r\n";
    return $data;
  }

  protected static function multipartEncodeText($name, $value) {
    $mimeType = 'text/plain';
    $data = "Content-Disposition: form-data: name=\"$name\" filename=\"$name\"\r\n";
    $data .= "Content-Transfer-Encoding: UTF-8\r\n";
    $data .= "Content-Type: $mimeType\r\n\r\n";
    $data .= "$value\r\n";
    return $data;
    return "Content-Disposition: form-data; name=\"$name\"\r\n\r\n$value\r\n";
  }

}
